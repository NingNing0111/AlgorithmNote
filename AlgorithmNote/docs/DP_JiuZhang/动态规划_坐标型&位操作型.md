# 动态规划-坐标型&位操作型

## 1. 坐标型

- 坐标型动态规划是最简单的动态规划类型
- 给定一个序列或网格

- 找到序列中某个/些子序列或网格中的某条路径。
 >
 > - 某种性质最大/最小问题
 > - 计数问题
 > - 存在性问题

- 动态规划方程$f[i]$中的下标i表示为以$a_i$结尾的满足条件的子序列的性质，$f[i][j]$中的下标$i,j$表示以格子$(i,j)$为结尾的满足条件的路径的性质。
 >
 > - 最大/最小问题
 > - 个数问题
 > - 是否存在

- 坐标型动态规划的初始条件$f[0]$就是以%a_0%为结尾的子序列的性质。

### 题目一

*给定m行n列的网格，有一个机器人从左上角(1,1)出发，每一步可以向下或者向右走一步。网格中有些地方有障碍，机器人不能通过障碍格。问有多少种不同的方式走到右下角。*

 **确定状态：**

- $f[i][j]$ 表示从左上角有多少种方式走到格子$(i,j)$上。
- 若$(i,j)$上有障碍，则$f[i][j]=0$。不能走到障碍上面。
- 若$(1,j)$，则$f[1][j]=f[1][j-1]$ ;若$(i,1)$,则$f[i][1] = f[i-1][1]$。因为只能向下或向右，若中间有障碍，则之后的坐标就无法到达。

 **状态转移**:

- $f[i][j] = f[i-1][j] + f[i][j-1]$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int mp[105][105],f[105][105];
int n,m;

int main()
{
    cin >> n >> m;
    for(int i=1; i<=m; i++)
    {
        for(int j=1; j<=n; j++)
        {
            cin >> mp[i][j];
        }
    }
    if(mp[1][1] || mp[m][n])
    {
        cout << "NO" << endl;
        return 0;
    }
    f[1][1] = 1;
    // 第一列
    for(int i=2; i<=m; i++)
    {
        // 如果有障碍
        if(mp[i][1])
        {
            f[i][1] = 0;
        }
        else
        {
            f[i][1] = f[i-1][1];
        }
    }
    // 第一行
    for(int i=2; i<=n; i++)
    {
        // 如果有障碍
        if(mp[1][i]){
            f[1][i] = 0;
        }else{
            f[1][i] = f[1][i-1];
        }
    }
    // 其它
    for(int i=2; i<=m; i++)
    {
        for(int j=2; j<=n; j++)
        {
            // 如果有障碍
            if(mp[i][j]){
                f[i][j] = 0;
            }else{
                f[i][j] = f[i-1][j] + f[i][j-1];
            }
        }
    }
    cout << f[m][n] << endl;
    return 0;
}

```

### 题目二

*给定$a[0],...,a[n-1]$*。找到最长的连续子序列$i,i+1,...,j$,使得$a[i] < a[i+1] < ... < a[j]$或者$a[i]>a[i+1]>...>a[j]$,输出长度$j-i+1$

 **确定状态**

- 对于$a[i]>a[i+1]>...>a[j]$的最长序列，我们可以将整个$a$序列转置，就称为了求最长连续上升子序列。
- 因此，题目就只需考虑找到序列$a$和序列$a$转置后的最长连续上升子序列：$a[i] < a[i+1] < ... < a[j]$。
- 从最后的状态来看，最长序列都有最后一个元素$a[i]$。（因为序列是连续的）
- 第一种情况:最长连续序列就是{$a[j]$},答案就是1
- 第二种情况:子序列长度大于1，那么最长连续序列一定是以$a[j-1]$结尾的最长序列 + 1；
- 状态$f[i]$:表示以元素$a[i]$结尾的最长序列长度

**状态转移**

- $f[i] = min\{1,f[i-1]+1 || i>0 and a[i-1] < a[i] \}$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int a[105];
int n;
// 求最长连续上升子序列
int List(int a[],int n)
{
    int f[105];
    int res = 0;
    for(int i=0;i<n;i++){
        f[i] = 1;
        if(i>0 && a[i] > a[i-1]){
            f[i] = f[i-1] + 1;
        }
        res = max(res,f[i]);
    }

    return res;
}

int main()
{
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> a[i];
    }
    // 原数组的最长连续上升子序列
    int res1 = List(a,n);
    int t;
    // 数组翻转
    for(int i=0;i<=(n-1)/2;i++){
        t = a[i];
        a[i] = a[n-1-i];
        a[n-1-i] = t;
    }
    // 转置后的最长连续上升子序列
    int res2 = List(a,n);
    // 输出二者的最大值
    cout << max(res1,res2) << endl;
    return 0;
}

```

### 题目三

*给定m行n列的网格，每个格子$(i,j)$里都有一个非负数$a[i][j]$。求一个从左上角$(0,0)$到右下角的路径，每一步只能向下或者向右走一步，使得路径上的格子数之和最小。输出最小数字和。*

 **确定状态**

- 对于最后一步，最小数之和一定等于走到$(m-2,j)$或者走到$(i,n-2)$的最小数之和加上a$[m-1][n-1]$;
- $f[i][j]$表示走到$(i,j)$上的最小数字之和

**状态转移**

- $f[i][j] = min\{ f[i-1][j],f[i][j-1] \} + a[i][j]$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int m,n;
int a[105][105];
int f[105][105];
int MAX = 1e8;

int main()
{
    cin >> m >> n;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            cin >> a[i][j];
        }
    }

    for(int i=0;i<m;i++){

        for(int j=0;j<n;j++){
            if(i == 0 && j == 0){
                f[i][j] = a[i][j];
                continue;
            }
            int t = MAX;
            if(i>0){
                // 与上方比较
                t = min(t, f[i-1][j]);
            }
            if(j > 0){
                // 与左方比较
                t = min(t,f[i][j-1]);
            }
            f[i][j] = t + a[i][j];
        }
    }
    cout << f[m-1][n-1] << endl;

    return 0;
}

```

### 题目四

*有一个M\*N的网格，每个格子可能是空的，可能有一个敌人，可能有一堵墙。只能在某个空格子里放一个炸弹，炸弹会炸死所有同行同列的敌人，但是不能穿透墙。最多能炸死几个敌人？*

|0|E|0|0|
|:-----:|:-----:|:-----:|:-----:|
|E|0|W|E|
|0|E|0|0|

 **确定状态**

- 每个炸弹可以往四个方向传播，我们可以分析一个方向，然后举一反三。
- 假设有敌人或有墙的格子也能放炸弹。
 >
 > - 有敌人的格子：格子里的敌人被炸死，并继续向上爆炸
 > - 有墙的格子: 炸弹不能炸死任何一个敌人
 >
- 在$(i,j)$格上放一个炸弹，它向上能炸死的敌人数是:
 >
 > - $(i,j)$格为空地:$(i-1,j)$格向上能炸死的敌人数
 > - $(i,j)$格为敌人:$(i-1,j)$格向上能炸死的敌人数 + 1
 > - $(i,j)$格为墙:0
 >
- 设$Up[i][j]$表示$(i,j)$格上放炸弹向上能炸死多少人。

 **状态转移**

- $Up[i][j] = Up[i-1][j]$,如果$(i,j)$是空地
- $Up[i][j] = Up[i-1][j] + 1$,如果$(i,j)$是敌人
- $Up[i][j] = 0$,$(i,j)$是墙

 初始条件

- 若$(0,j)$不是敌人,$Up[0][j] = 0$
- 若$(0,j)$是敌人,$Up[0][j] = 1$

 上述分析只是针对向上的方向，其它方向同理，只是计算计算顺序有所不同。

- 向上:  上方的格子先进行了计算
- 向下:  下方的格子先进行了计算
- 向左： 左方的格子先进行了计算
- 向右： 右方的格子先进行了计算

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int m,n;
char mp[105][105];
int up[105][105],down[105][105],Left[105][105],Right[105][105];

int main()
{
    cin >> m >> n;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            cin >> mp[i][j];
        }
    }

    int res = 0;
    // 向上
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(mp[i][j] == 'W'){
                up[i][j] = 0;
                continue;
            }
            up[i][j] = mp[i][j] == 'E' ? 1 : 0;
            if(i > 0){
                up[i][j] += up[i-1][j];
            }
        }
    }
    // 向下
    for(int i=m-1;i>=0;i--){
        for(int j=0;j<n;j++){
            if(mp[i][j] == 'W'){
                down[i][j] = 0;
                continue;
            }
            down[i][j] = mp[i][j] == 'E' ? 1 : 0;
            if(i < m-1 ){
                down[i][j] += down[i+1][j];
            }
        }
    }
    // 向左
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(mp[i][j] == 'W'){
                Left[i][j] = 0;
                continue;
            }
            Left[i][j] = mp[i][j] == 'E' ? 1 : 0;
            if(j > 0){
                Left[i][j] += Left[i][j-1];
            }
        }
    }
    // 向右
    for(int i=0;i<m;i++){
        for(int j=n-1;j>=0;j--){
            if(mp[i][j] == 'W'){
                Right[i][j] = 0;
                continue;
            }
            Right[i][j] = mp[i][j] == 'E' ? 1 : 0;
            if(j <n-1 ){
                Right[i][j] += Right[i][j+1];
            }
        }
    }
    // 求最大
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(mp[i][j] == '0'){
                int t = up[i][j] + down[i][j] + Left[i][j] + Right[i][j];
                res = max(t,res);
            }
        }
    }
    cout << res << endl;
    return 0;
}

```

### 坐标型动态规划总结
>
> 给定的输入为序列或者网格/矩阵

> 动态规划状态下标为序列下标$i$或者网格坐标$(i,j)$
>
> - $f[i]$ :以第$i$个元素结尾的某种性质
> - $f[i][j]$:到格子$(i,j)$的路径的性质

## 2. 位操作型动态规划
>
> - 位操作(二进制)
> - & 与 、 | 或 、 ^异或 、 !非

### 题目一

*给定N，要求输出0,1,...,N的每个数的二进制表示的1的个数*

 **确定状态**

- 观察第$i$个数最后一个二进制位，去掉它，看还有多少个1.
 要求N的二进制表示有多少个1 = 在N的二进制去掉最后一位$N mod 2$的数的二进制1的个数 + 最后一位是否为1
- $f[i]$:表示第$i$的二进制表示中有多少个1

 **状态转移**

- $f[i] = f[i>>1] + (i mod 2)$
- $i$的二进制表示中有多少个1 = $i$的二进制表示中去掉最后一位，剩下的1的个数 + $i$的二进制表示中最后一位

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int f[105];

int main()
{
    cin >> n;
    f[0] = 0;
    for(int i=1;i<=n;i++){
        f[i] = f[i>>1] + i%2;
    }
    for(int i=0;i<=n;i++){
        cout << f[i] << " ";
    }
    return 0;
}

```
