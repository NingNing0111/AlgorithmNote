## 动态规划-序列型

 1. 给定一个序列
 2. 动态规划方程$f[i]$中的下标$i$表示前$i$个元素$a[0],a[1],...,a[i-1]$的某种性质。
 >
 > - 坐标型的$f[i]$表示以$a_i$为结尾的某种性质
 >
 3. 初始化中,$f[0]$表示空序列的性质
 >
 > - 坐标型动态规划的初始条件$f[0]$就是指以$a_0$为结尾的子序列的性质。

### 题目一

*有一排N栋房子，每栋房子要漆成3种颜色中的一种:红、蓝、绿。任何两栋相邻的房子不能漆成同样的颜色。第i栋房子染成红色、蓝色、绿色的花费分别是$cost[i][0],cost[i][1],cost[i][2]$.问最少需要花多少钱油漆这些房子。*

 **确定状态**

- 依据最初思想，确定第N栋房子的最小花费 = (前N-1种的最小花费 + 染第N栋房子的最小花费) && (第N栋房子的颜色 ！= 第N-1栋房子的颜色)
- 我们不能判断第$i$栋房子的最小花费下是什么颜色的，因此需要把每栋房子染成红、蓝、绿的最小花费记录下来。
- $f[i][0],f[i][1],f[i][2]$ 分别表示第$i$栋房子染成红色、蓝色、绿色的最小花费。

 **状态转移**

- $f[i][j] = min \{ f[i-1][k_1] + a[i][j], f[i-1][k_2] + a[i][j] \}$;$j!=k_1,k_2$
- 第$i$栋房子染成第$j$颜色的最小总花费等于第$i-1$栋房子染成$k$颜色的最小花费 + 第$i$栋房子染成第$j$个颜色的费用，其中$j!=k$,并在$k$区间内取最小值。

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int a[105][3];
int f[105][3];
const int MAX = 1e8;

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i][0] >> a[i][1] >> a[i][2];
    }
    f[0][0] = f[0][1] = f[0][2] = 0;
    for(int i=1;i<=n;i++){
        // 第i栋房子染为第j个颜色
        for(int j=0;j<3;j++){
            f[i][j] = MAX;
            // 第i-1栋房子染成第k个颜色的代价
            for(int k = 0;k<3;k++){
                // 颜色不一样
                if(j!=k){
                    f[i][j] = min(f[i][j], f[i-1][k] + a[i][j]);
                }
            }
        }
    }

    cout << min(f[n][0],min(f[n][1],f[n][2])) << endl;
    return 0;
}

```

### 题目二

*有一排N栋房子，每栋房子要漆成K中颜色中的一种，任何两栋相邻的房子不能漆成同样的颜色。房子$i$染成第$j$种颜色的花费是$cost[i][j]$.问最少需要花多少钱油漆这些房子？*

 **确定状态**

- 第$N$栋的最小花费 = (第$N-1$栋的最小花费 + 第N栋染色的最小花费$cost[N][k]$,颜色为k ) && ( $k$ != 第$N-1$栋房子的颜色)
- 因为无法判断第$i$栋房子的最小花费是染成什么颜色，因此需要将第$i$栋房子染成各个颜色的最小花费记录下来。在计算完$1-N$栋房子的染色最小花费后，直接遍历第$N$栋房子的各个颜色的最小花费即是所求。
- $f[i][j]$ 表示第$i$栋房子染成$j$颜色的最小花费。

 **状态转移**

- $f[i][j] = min\{ f[i-1][k_n] + a[i][j], (n=1,2,3,...,k)  \&\& (k_n!=j)\}$

#### 代码1

```C++
#include<bits/stdc++.h>

using namespace std;

int n,m;
int cost[105][105];
int f[105][105];
const int MAX = 1e8;

int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin >> cost[i][j];
        }
    }

    for(int i=1;i<=n;i++){

        for(int j=1;j<=m;j++){
            f[i][j] = MAX;
            for(int k=1;k<=m;k++){
                if(j!=k){
                    f[i][j] = min(f[i][j],f[i-1][k] + cost[i][j]);
                }
            }
        }

    }

    int ans = f[n][1];
    for(int i=1;i<=m;i++){
        ans = min(ans,f[n][i]);
    }
    cout << ans << endl;
    return 0;
}
```

 上述代码的时间复杂度为$O(mn^2)$

 **优化思路**

- 从状态转移方程$f[i][j] = min\{ f[i-1][k_n] + a[i][j]\}$可以发现，每次求$f[i][j]$都需要求出$f[i-1][j]$以外的最小值。
- 因此只需遍历$f[i-1][k_j],j=1,2,...,k$找到最小值和次最小值(因为$f[i-1][j]$是最小值时，需要用次最小值).
- 若最小值是$f[i-1][a]$,次最小值是$f[i-1][b]$。
  >
  > 1. $f[i][j] = f[i-1][a] + cost[i][j]$
  > 2. $f[i][a] = f[i-1][b] + cost[i][a]$

 时间复杂度降为了$O(nm)$

#### 代码2

```C++
#include<bits/stdc++.h>

using namespace std;

int n,m;
int cost[105][105];
int f[105][105];
const int MAX = 1e8;

int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin >> cost[i][j];
        }
    }
    int min1,min2,ind1=0,ind2=0;// ind1,ind2分别表示最小值和次最小值的颜色
    for(int i=1;i<=n;i++){
        min1 = min2 = MAX;
        // 找到最小和次小值
        for(int j=1;j<=m;j++){
            // 如果f[i-1][j]小于最小值
            if(f[i-1][j] < min1){
                // 将原最小值赋值给次最小值
                min2 = min1;
                ind2 = ind1;
                // 现最小值就为f[i-1][j],记录颜色 
                min1 = f[i-1][j];
                ind1 = j;
            }else{
                // 小于次最小值，则更新次最小值即可
                if(f[i-1][j] < min2){
                    min2 = f[i-1][j];
                    ind2 = j;
                }
            }
        }
        
        for(int j=1;j<=m;j++){
            f[i][j] = cost[i][j];
            // 如果j不是最小值的颜色，就直接加最小值
            if(j!=ind1){
                f[i][j] += min1;
            // 否则，加次最小值
            }else{
                f[i][j] += min2;
            }
        }
    }
    int ans = f[n][1];
    for(int i=1;i<=m;i++){
        ans = min(ans,f[n][i]);
    }
    cout << ans << endl;
    return 0;
}
```

> 上述是一种常见的优化方式

### 题目三

*有一排N栋房子，房子$i$里有$A[i]$个金币。一个窃贼想选择一些房子偷金币。但不能偷任何挨着的两家，否则会被警察逮住。问最多能偷多少金币。*

 **确定状态**

- 考虑最后一栋房子，有两种情况：
 >
 > - 最后一栋不偷，则最优策略就是前$N-1$的最优策略
 > - 最后一栋偷，则最优策略就是前$N-2$的最优策略 + $A[N]$

- $f[i][0]$表示不偷$i$栋房子的最优策略
- $f[i][1]$表示偷$i$栋房子的最优策略

 **状态转移**

- f[i][0] = max{f[i-1][0],f[i-1][1]}

 > 因为不偷第$i$栋房子，因此，房子$i-1$可以选择偷和不偷

- f[i][1] = f[i-1][0] + A[i]

 > 因为要偷第$i$栋房子，因此第$i-1$栋房子必须不能偷

#### 代码1

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int A[105],f[105][2];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> A[i];
    }

    for(int i=1;i<=n;i++){
        // 第i栋房子不偷，则返回第i-1栋房子偷和不偷的最大价值
        f[i][0] = max(f[i-1][0],f[i-1][1]);
        // 第i栋房子偷，则返回第i-1栋房子不偷的最大价值 + 第i栋房子的价值
        f[i][1] = f[i-1][0] + A[i];
    }
    // 返回第n栋房子偷和不偷的情况下 最大价值
    cout << max(f[n][0],f[n][1]) << endl;
    return 0;
}

```

 **优化策略**

- 第$i$栋房子的最大价值 = $max \{ $ 第i-1栋房子的最大价值,第i-2栋房子的最大价值 + 第$i$栋房子的价值$\}$
- $f[i]$表示第$i$栋房子的最大价值
- $f[i] = max\{f[i-1],f[i-2] + A[i]\}$

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int A[105],f[105];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> A[i];
    }
    // 初始条件
    f[0] = 0;
    f[1] = A[1];
    f[2] = max(f[1],f[0]+A[2]);

    for(int i=3;i<=n;i++){
        f[i] = max(f[i-1],f[i-2]+A[i]);
    }
    cout << f[n] << endl;
    return 0;
}

```

### 题目四

*有一圈N栋房子，房子i里有$A[i]$个金币。一个窃贼想选择一些房子偷金币。但是不能偷任何挨着的两家邻居，否则会被警察逮住。问最多能偷多少金币？*

> 该题与上题类似，唯一不同的在于头尾相邻了

 **确定状态**

- 考虑最后一栋房子，共有两种情况

  1. 要么偷了第N栋房子，没偷第1栋房子
  >
  > 此时就是从一排2到N的房子里偷，变为了序列情况
  >
  2. 要么偷了第1栋房子，没偷第N栋房子
  >
  > 此时就是从一排1到N-1栋房子里偷，变为了序列情况
  >
- 尽管圈的情况比序列复杂，但是通过首尾不可连续原理，进行分情况讨论，转换为序列情况。

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,ans;
int a[105],f[105],t[105];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    // 偷1到N-1的房子
    for(int i=1;i<=n-1;i++){
        t[i] = a[i];
    }

    f[0] = 0;
    f[1] = t[1];
    f[2] = max(f[0]+t[2],f[1]);
    for(int i=3;i<=n-1;i++){
        f[i] = max(f[i-1],f[i-2]+t[i]);
    }
    ans = f[n-1];

    // 偷2到N栋房子
    for(int i=2;i<=n;i++){
        t[i-1] = a[i];
    }

    f[0] = 0;
    f[1] = t[1];
    f[2] = max(f[0]+t[2],f[1]);
    for(int i=3;i<=n-1;i++){
        f[i] = max(f[i-1],f[i-2]+t[i]);
    }

    // 取两种情况的最小值
    ans = max(ans,f[n-1]);
    cout << ans <<endl;

    return 0;
}

```

### 题目五

*已知后面N天一支股票的每天价格$P_1,P_1,...,P_n$。可以最多买一股卖一股。求最大利益。*

 示例
> 输入: 3 2 3 1 2
> 输出: 1 (2买入，3卖出)

 **分析**

- 保底策略，什么都不做，利润为0.（因为P序列可能是递减序列）
- 第$j$天卖得到的最大利润 = $P_j$ - $P_i$ && $P_i = min\{P_k,k<=j\}$
- 第$j$天得到的最大利润等于$j$天的股票价格 - 前$j$天里最小的股票价格。
- 需要一个额外的变量$V$记录前$j$天的最小股票价格

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int p[105];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> p[i];
    }
    int v = p[1],ans=0;
    for(int i=2;i<=n;i++){

        ans = max(ans,p[i]-v);
        // 记录最小值
        if(p[i] < v){
            v = p[i];
        }
    }
    cout << ans;
    return 0;
}


```

### 题目六

*已知后面N天一支股票的每天价格$P_1,P_1,...,P_n$。可以买卖任意多次股票，但同一时刻只能持有一支股票。求最大利益。*

示例
> 输入: 2 1 2 0 1
> 输出: 2 (1买入，2卖出，0买入，1卖出)

**确定状态**

- 考虑最后一次交易完成后，共有两种情况，手上有股票和手上没有股票。

 > - 最后一次交易完成后，手上有股票，说明前一天有股票或者前一天没有股票但这次交易买入了股票
>
> - 最后一次交易完成后，手上没有股票，说明前一天没有股票或者前一天有股票但这次交易卖了股票

- $f[i][0]$表示第$i$次交易后，手上没有股票的最大利润
- $f[i][1]$表示第$i$次交易后，手上有股票的最大利润

 **状态转移**

- 第$i$次交易后，手上没有股票的最大利润 = $max\{$第$i-1$次交易没有股票的最大利润$,$第$i-1$次有股票的最大利润 + 第$i$天的股票价格$\}$
- $f[i][0] = max\{f[i-1][0],f[i-1][1] + P[i]\}$

- 第$i$次交易后，手上有股票的最大利润 = $max\{$第$i-1$次交易有股票的最大利润，第$i-1$次没有股票的最大利润 - 第$i$天的股票价格$\}$
- $f[i][1] = max\{f[i-1][1],f[i-1][0] - P[i] \}$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n;
int P[105],f[105][2];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> P[i];
    }
    // 第0天不可能持有股票，为保证第1天买入股票后利润为0，将其初始化为-P[1]
    f[0][1] = -P[1];
    for(int i=1;i<=n;i++){
        f[i][0] = max(f[i-1][0],f[i-1][1] + P[i]);
        f[i][1] = max(f[i-1][1],f[i-1][0] - P[i]);
    }
    // 最大利润就是手上没有股票的情况下
    cout << f[n][0] << endl;


    return 0;
}
```

### 题目七

*给定一支股票N天的价格。可以进行最多两次买和卖，每次买卖都是一股。不能在卖光手中股票前买入，但可以同一天卖完后买入。求最大利润。*

 **确定状态**

- 考虑最后一次交易后的最大利润 = 前一次的交易最大利润 + 最后一次股票卖和不卖的最优决策
- 前一次的最大利润分为五种情况:
 >
 > 1. 尚未买入股票
 > 2. 已完成了第一次买，手上持有股票
 > 3. 已完成了第一次卖，手上没有股票
 > 4. 已完成了第二次买，手上持有股票
 > 5. 已完成了第二次卖，手上没有股票

- $f[i][j]$分别表示第i次交易完成后的第j种情况的最大利润

 **状态转移**

- 最后一次交易后手上无股票的最大利润(情况1,3,5) = max{前一次交易后无股票的最大利润(情况1,3,5) , 前一次交易后有股票的最大利润(情况2,4) + 当天持有股票的持续利润}
- 情况1,3,5： $f[i][j] = max\{f[i-1][j],f[i-1][j-1] + P[i]-P[i-1] \}$

- 最后一次交易手上有股票的最大利润(情况2,4) = max{前一次交易有股票的最大利润(情况2,4)+当天卖出的持续获利利润, 前一次交易无股票的最大利润(情况1,3,5)}
- 情况2,4： $f[i][j] = max\{f[i-1][j] + P[i]-P[i-1],f[i-1][j-1]\}$

- 最终结果: $ans = max\{f[n][j],j=1,3,5\}$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,P[105],f[105][6];


int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> P[i];
    }

    f[0][1] = 0;
    for(int i=2;i<=5;i++){
        f[0][i] = -1e8;
    }
    for(int i=1;i<=n;i++){

        // 1 3 5 情况
        for(int j=1;j<=5;j+=2){
            f[i][j] = f[i-1][j];
            if( j>1 && i>=2 && f[i-1][j-1] != -1e8){
                f[i][j] = max(f[i][j],f[i-1][j-1] + P[i] - P[i-1]);
            }
        }

        // 2 4 情况
        for(int j=2;j<=5;j+=2){
            f[i][j] = f[i-1][j-1];
            if(i>=2 && f[i-1][j-1] != -1e8){
                f[i][j] = max(f[i][j],f[i-1][j] + P[i] - P[i-1]);
            }

        }

    }
    cout << max(f[n][1],max(f[n][3],f[n][5])) << endl;

    return 0;
}

```

### 题目八

*给定一支股票N天的价格。可以进行最多K次买和K次卖，每次买卖都是一股。不能在卖光手中股票前买入，但可以在同一天卖完后买入。求最大收益。*

> - 1次买卖 有 3种情况
> - 2次买卖 有 5中情况
> - k次买卖 有 2*k+1种情况
> - 将题目六的代码中，5替换为2*k+1,然后在情况$1,3,5,...,2*k+1$中找到最大值即可.
> - 若$k>n/2$,则该题就转化为无限买卖的最大收益（类似题目五）

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,k,P[105],f[105][105];


int main()
{
    cin >> n >> k;
    for(int i=1;i<=n;i++){
        cin >> P[i];
    }
    
    if(k > n/2){
        for(int i=1;i< n;i++){
            if(P[i+1] > P[i]){
                ans += (P[i+1]-P[i]);
            }
        }
        cout << ans << endl;
        return 0;
    }
    
    f[0][1] = 0;
    for(int i=2;i<=2*k+1;i++){
        f[0][i] = -1e8;
    }
    for(int i=1;i<=n;i++){

        // 1 3 5 ... 2*k+1 情况
        for(int j=1;j<=2*k+1;j+=2){
            f[i][j] = f[i-1][j];
            if( j>1 && i>=2 && f[i-1][j-1] != -1e8){
                f[i][j] = max(f[i][j],f[i-1][j-1] + P[i] - P[i-1]);
            }
        }

        // 2 4 ... 2*k 情况
        for(int j=2;j<=2*k+1;j+=2){
            f[i][j] = f[i-1][j-1];
            if(i>=2 && f[i-1][j] != -1e8){
                f[i][j] = max(f[i][j],f[i-1][j] + P[i] - P[i-1]);
            }

        }

    }
    int ans = 0;
    for(int i=1;i<=2*k+1;i+=2){
        ans = max(ans,f[n][i]);
    }

    cout << ans << endl;

    return 0;
}
```

## 最长序列型动态规划

- 给定一个序列
- 找出符合条件的最长子序列
- 方法
 >
 > - 记录以每个元素$i$结尾的最长子序列的长度
 > - 计算时，在$i$之前枚举子序列上一个元素是哪个
 >
- 为坐标型动态规划

### 题目九

*给定$a[1],a[2],...,a[n]$，找到最长的子序列$0<=i_1<i_2<...<i_k<n$*,使得$a[i_1]<a[i_2]<...<a[i_k]$,输出k

 我们可以求出以某个元素$a[i]$结尾的最长上升子序列的长度，然后遍历获得最大值。

 **确定状态**

1. 对于以某个元素$a[i]$结尾的最长上升子序列的长度有两种情况
  长度等于1 序列为自身，长度为1.
  长度大于1以$a[i]$结尾的序列长度 =  以元素$a[j]$结尾的最长上升子序列 + 1 $\&\&$ $(a[i] > a[j])$,$j < i$.

2. $f[i]$ : 以第$i$个元素结尾的最长上升子序列的长度

 **状态转移**

$$
f[i] = max\{1,f[j] + 1 \&\& a[i] > a[j]\}
$$

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,ans=0;
int a[105],f[105];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }

    for(int i =1;i<=n;i++){
        f[i] = 1;
        for(int j=1;j < i;j++){
            if(a[i] > a[j]){
                f[i] = max(f[j]+1,f[i]);
            }
        }
        ans = max(ans,f[i]);
    }
    cout << ans << endl;
    return 0;
}

```

### 题目十

*给定N个信封的长度和宽度。如果一个信封的长和宽都分别小于另一个信封的长和宽，则可以放入另一信封。问最多可以嵌套多少个信封？*

 **确定状态**

- 信封$i$能嵌套进信封$j$的前提是信封$j$的长度和宽度均大于信封$i$的长度和宽度。
- 若我们先按信封的长度进行排序，则信封$i$能嵌套进信封$j$的前提就是信封$j$的宽度大于信封$i$的宽度。
- 第$i$封信封能嵌套的信封数 = 第$j$封信封能嵌套的信封数 + 1 $\&\&$ $i$的宽度大于$j$的宽度 。
- $f[i]$第$i$封信封能嵌套的最多嵌套数。

 **状态转移**

- $f[i] = max\{ 1, f[j] + 1 \&\& i的长度和宽度均大于j的长度和宽度$\}

#### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

struct Node{
    int w,l;
}a[105];

// 按宽度从小到大排
bool cmp(Node aa, Node bb){
    return aa.w < bb.w;
}

int n,f[105],ans;

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i].w >> a[i].l;
    }

    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++){
        f[i] = 1;
        for(int j=1;j<i;j++){
            // 宽度重新判断是因为宽度可能相等
            if(a[i].l > a[j].l && a[i].w > a[j].w){
                f[i] = max(f[i],f[j]+1);
            }
        }
        ans = max(ans,f[i]);
    }

    cout << ans << endl;

    return 0;
}

```
