# 动态规划 - 划分型

**1. 划分型动态规划是一类常见的动态规划**。

**2. 给定长度为N的序列或字符串，要求划分成若干段**

- 段数不限或指定K段
- 每一段满足一定的性质

**3. 做法**

- 类似于序列型动态规划，但是通常要加上段数信息
- 一般用$f[i][j]$记录前i个元素(元素$1-i$ ) 分成$j$段的性质，如最小代价。

## 题目一

*有一段由A-Z组成的字母串信息被加密成数字串。加密方式为：A->1,B->2,...,Z->26。给定加密后的字符串S[0...N-1],问有多少中方式解密成字符串？*

> 确定状态

- 给定一个加密的字符串后，我们将其划分为若干段数字，每段数字可以解密成一个字母。
- 对于长度为N的加密后的字符串，从最后一步来说，若按一个位数进行划分，则方式数等于字符串前N-1的方式数；若按两位数进行划分，则方式数等于字符串前N-2的方式数。
- $f[i]$表示字符串$s$前$i$个数字解密成字符的方式数。

> 状态转移

- 字符串S前i个数字解密成字母的方式数 = 前i-1个数字解密成字母的方式数 + 前i-2个数字解密成字母的方式数。
- $f[i] = f[i-1] + f[i-2]$
- 需要判断$s[i],s[i-1]s[i]$能否被解释为一个字母

### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int f[105];

int main()
{
    string s;
    cin >> s;
    f[0] = 1;
    int len = s.length();
    for(int i=1;i<=len;i++){

        // 1位
        if( s[i-1] >= '0' && s[i-1] <= '9'){
            f[i] += f[i-1];
        }
        // 多位时 考虑2位
        if(i>1){
            int num = (s[i-2] - '0')*10 + (s[i-1]-'0');
            // 防止出现 01 -> A 的情况
            if(num > 9 && num < 27){
                f[i] += f[i-2];
            }
        }
    }
    cout << f[len] << endl;
    return 0;
}

```

## 题目二

*给定一个正整数。问最少可以将n分成几个完全平方数之和。*

> 确定状态
>
> - 最后一步：关注的是最优策略中最后一个完全平方数$j^2$.
> - 最优策略中$n-j^2$也一定被划分成最少的完全平方数之和
> - $f[i]$:表示$i$最少能被划分成几个完全平方数之和
>
> 状态转移
>
> - $f[i] = min\{ f[i-j^2]+1, j^2 <= i\}$

### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,f[105];

int main()
{
    cin >> n;
    f[0] = 0;
    for(int i=1;i<=n;i++){
        f[i] = 1e8;
        for(int j=1;j*j<=i;j++){
            f[i] = min(f[i],f[i-j*j]+1);
        }
    }
    cout << f[n] << endl;

    return 0;
}

```

## 题目三

*给定一个字符串S[0...N-1]。要求将这些字符串划分成若干段，每一段都是一个回文串。求最少划分几次？*

> 确定状态
>
> - 对于最后一个回文字符串$S[j...N-1]$，我们只需要知道前$j$个字符串最少划分次数 + 1即可。
> - 也就是说，求$S[0...N-1]$最少可以划分几次只需要求出$S[0...j]$最少可以划分几次。
> - $f[i]$表示前$i$个字符最少可以划分为几个回文串。
>
> 状态转移
>
> - $f[i] = min\{f[j] + 1 ，\&\& S[j...i-1]是回文串 \}$
> - $f[0] = 0$

```C++
#include<bits/stdc++.h>

using namespace std;

string str;
int f[105];
// 判断回文字符串
bool isBack(int st,int ed){
    int i=st,j=ed;
    while(i<=j){
        if(str[i] != str[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;
}

int main()
{
    cin >> str;
    int len = str.length();
    f[0] = 0;
    for(int i=1;i<=len;i++){
        f[i] = 1e8;
        for(int j=0;j<i;j++){
            if(isBack(j,i-1)){
                f[i] = min(f[i],f[j] + 1);
            }
        }
    }
    // f[len]表示前len个字符最少可以划分多少个回文串
    // f[len]-1表示的就是划分次数
    cout << f[len] -1 << endl;
    return 0;
}

```

## 题目四

*有N本书需要被抄写，第$i$本书有$A[i]$页,i=1,2,...,N。有K个抄写原，每个抄写员可以抄写连续的若干本书。每个抄写员的抄写速度都一样，均为一分钟一页。问最少需要多少时间抄写完所有的书？*

> 确定状态
>
> - 如果一个抄写员抄写第$i$本到第$j$本书，则需要时间$A[i]+A[i+1]+...+A[j]$.
> - 最后的抄写完成时间取决于耗时最长的那位抄写员。--- 木桶原理
> - 题目就转化为：找到一种分段方式，分成不超过K段，使得所有段的数字之和的最大值最小。
> - 最优策略的最后一步：抄写员K，抄写一段连续的书 $j,j+1,...,N$
> - 第K个抄写员需要的时间$A[j] + A[j+1]+...+A[N]$
> - 最后的最优策略中就需要知道前$K-1$人抄写$j-1$本书的最小时间花费。
> >
> > 1. 因为整体工程的抄写耗时最长的抄写员可能是第K个抄写员 也可能是前面K-1位抄写员的其中一位。若抄写耗时最长的抄写员为第K个抄写员，则答案就是第K个抄写员的抄写耗时时长。
> > 2. 另一方面，要保证每段的数字之和的最大值最小，需要知道前K-1个人抄写前j-1本书的最小时间花费。
> >
> - 原：求K个人最短需要多少时间抄写完前N本书？
> - 现: 求K-1个人最短需要多少时间抄写完前j-1本书
> - $f[k][i]$:K个抄写员最少需要多少时间抄写完前$i$本书。
>
> 状态转移
>
> - $f[k][i] = min\{ max\{f[k-1][j-1],sum = \sum_{j=1}^{i} A[j] \} ,j=1,2,...,i\}$
> - $f[k][i]$: k个抄写员最少需要多少时间抄写完前$i$本书
> - $f[k-1][j-1]$: K-1个抄写员最少需要多少时间抄写$j-1$本书
> - $A[j] + ... + A[i]$:第k个抄写员抄写完第$j$至第$i$本书的时间
> - $f[0][i] = MAX$: 0个抄写员抄写i本书的时间花费为无穷大，因为无法完成抄写
> - $f[k][0] = 0$：K个抄写员抄写0本书的时间花费为0

### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int N,K,a[105],f[105][105];

int main()
{
    cin >> N >> K;
    for(int i=1;i<=N;i++){
        cin >> a[i];
        f[0][i] = 1e8;
    }

    for(int k=1;k<=K;k++){
        f[k][0] = 0;
        for(int i=1;i<=N;i++){
            f[k][i] = 1e8;
            int sum = 0;
            // 抄写 j到i本书的最小花费，j = 1,...,i
            for(int j=i+1;j>=1;j--){
                f[k][i] = min(f[k][i],max(f[k-1][j-1],sum));
                sum += a[j-1];
            }
        }
    }
    cout << f[K][N] << endl;
    return 0;
}

```

## 总结
>
> - 划分型动态规划一般要求将一个序列或字符串划分成若干满足要求的片段。
> - 解决方法：最后一步 ---> 最后一段，枚举最后一段的起点
> - 如果题目不指定段数，用$f[i]$表示前$i$个元素分段后的可行性/最值，方式数等
> - 如果题目指定段数，用$f[i][j]$表示前$i$个元素分成$j$段后的可行性/最值,方式数等
