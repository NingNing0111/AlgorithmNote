# 动态规划 - 博弈型

> - 博弈为两方游戏
> - 一方先下，称为先手，另外一方称为后手
> - 两方在一定规则下依次出招
> - 若满足一定条件，则一方胜，两者的目标一致，都是为了取胜。
> - 玩家出招后，先手换人，新的先手面对一个新的局面。
> - 博弈型动态规划一般从第一步分析，而不是最后一步进行分析。

> 必胜与必败的概念
>
> - 必胜: 先手做出决策后，能让剩下的局面先手必败，则当前先手必胜。
> - 必败：不能做出什么决策，剩下的局面都是先手必胜，则当前先手必败。
>
> 博弈宗旨：
>
> - 在当下的局面做出一个决策，让对手必败。

## 题目一

*有一排N个石子，A,B两个人轮流取石子。每次一个人可以从最右边取走1个或2个石子。取走最后石子的人获胜。问A为先手的的话，是否必胜？*

> 确定状态
>
> - 面对N个石子是否先手必胜，需要知道面对N-1或N-2个石子是否先手必胜。
> - 若面对N-1或N-2个石子的局面，先手是必胜的，则当前的先手就是必败的。
> - 面对N个石子的局面先手胜利 = 面对N-1个石子的局面先手是必败的 或者 面对N-2个石子的局面先手是必败的。
> - $f[i]$表示面对$i$个石子先手是否胜利
>
> 状态转移
>
> - $f[i] = f[i-1]==false OR f[i-2] == false$
> - $f[0] = false$
> - $f[1] = f[2] = true$

### 代码

```C++
#include<bits/stdc++.h>

using namespace std;

int n,f[105];

int main()
{
    cin >> n;
    f[0] = 0;
    f[1] = f[2] = 1;
    for(int i=2;i<=n;i++){
        f[i] = !f[i-1] || !f[i-2];
    }
    if(f[n]){
        cout << "True" << endl;
    }else{
        cout << "False" << endl;
    }
    return 0;
}

```
